% Студент работает летом спасателем на пляже. После того, как он заметил
% проблемы одного из пловцов, он стал пытаться найти путь, по которому он
% может достигнуть пловца за самое короткое время. Путь кратчайшего рас-
% стояния (путь A) очевидно, не лучший вариант, поскольку в этом случае уве-
% личивается время, потраченное на плавание (он может бежать быстрее, чем
% плавать). Путь B минимизирует время, затраченное на плавание, но является,
% вероятно, не лучшим вариантом, поскольку это самый длинный (разумный)
% путь. Ясно, что оптимальный путь находится где-нибудь между путями A и B.
% Рассмотрите промежуточный путь C и определите время, требуемое для
% достижения пловца, если скорость бега vrun = 3 м/с, а скорость его плавания
% vswim = 1 м/с; расстояния L = 48 м, ds = 30 м, и dw = 42 м; и боковое расстояние y,
% где спасатель входит в воду. Создайте вектор y, который располагается между
% путем A и путем B (y = 20, 21, …, 48 м) и вычислите время t для каждого значе-
% ния y. Используйте встроенную функциональную min MATLAB, чтобы найти
% минимальное время tmin и соответствующее место входа y. Определите углы,
% которые соответствуют расчетному значению y и выясните, удовлетворяет ли
% Ваш результат закону преломления Снеллиуса:
% sin(phi) / sin(alpha) = vrun / vswim

vrun  = 3;
vswim = 1;
L = 48;
ds = 30;
dw = 42;
y = 20:1:48;

lrun  = sqrt(y.^2 + ds^2);
lswim = sqrt((L - y).^2 + dw^2);

t = lrun / vrun + lswim / vswim;
[t_min, t_min_idx] = min(t);

y_best = y(t_min_idx);
sin_phi = y_best / lrun(t_min_idx);
sin_alpha = (L - y_best) / lswim(t_min_idx);

fprintf('Минимальное время %4.2f достигается при y=%4.2f\n', t_min, y(t_min_idx));
fprintf('Проверка по закону преломления Снеллиуса: sin(phi)/sin(alpha)=%3.2f, vrun/vswim=%3.2f\n', ...
    sin_phi / sin_alpha, vrun / vswim);


